#!/usr/bin/env node

import { writeFile } from "fs/promises";
import { relative, resolve } from "path";

const args = process.argv.slice(2);
if (args.length != 1) {
    console.error("Usage: npm run ast [path-to-ast-dir]");
    process.exit(64);
}

type AstTypeDefField = {
    name: string;
    type: string;
};

type AstTypeDef = {
    name: string;
    fields: AstTypeDefField[];
}

async function defineAst(outputDir: string, baseName: string, types: string[], imports?: string[]) {
    const typeDefs: AstTypeDef[] = types.map((type) => {
        const typeParts = type.split(":");
        return {
            name: typeParts[0].trim(),
            fields: typeParts[1].trim().split(",").map((field) => {
                const fieldParts = field.trim().split(" ");
                return {
                    name: fieldParts[fieldParts.length - 1],
                    type: fieldParts.slice(0, fieldParts.length - 1).join(" ")
                };
            })
        };
    });

    const fileLines: string[] = [
        `// WARNING: DO NOT EDIT THIS FILE MANUALLY!`,
        `// Please use the tool/generateAst.ts script using: \`npm run ast "${outputDir}"\``
    ];

    if (imports != null && imports.length > 0) {
        fileLines.push("", ...imports);
    }

    fileLines.push(
        ...defineVisitor(baseName, typeDefs),
        ...defineInterface(baseName),
        ...defineTypes(baseName, typeDefs)
    );

    await writeFile(resolve(`${outputDir}/${baseName}.ts`), fileLines.join("\n") + "\n", { flag: "w+" });
}

function defineVisitor(baseName: string, typeDefs: AstTypeDef[]): string[] {
    return [
        ``,
        `export interface Visitor<T> {`,
        ...typeDefs.map((type) => {
            return `    visit${type.name}${baseName}(${baseName.toLowerCase()}: ${type.name}): T;`;
        }),
        `}`
    ];
}

function defineInterface(baseName: string): string[] {
    return [
        ``,
        `export interface ${baseName} {`,
        `    accept<T>(visitor: Visitor<T>): T;`,
        `}`
    ];
}

function defineTypes(baseName: string, typeDefs: AstTypeDef[]): string[] {
    return typeDefs.reduce((lines, typeDef) => lines.concat([
        ``,
        `export class ${typeDef.name} implements ${baseName} {`,
        `    public constructor(`,
        ...typeDef.fields.map((field) => `        public readonly ${field.name}: ${field.type},`),
        `    ) { }`,
        ``,
        `    public accept<T>(visitor: Visitor<T>): T {`,
        `        return visitor.visit${typeDef.name}${baseName}(this);`,
        `    }`,
        `}`
    ]), [] as string[]);
}

// For more information about this file and syntax:
// http://craftinginterpreters.com/representing-code.html#metaprogramming-the-trees

const srcPath = relative(resolve(args[0]), resolve(__dirname + "/../src/")).replace("\\\\", "/"); // Some dark magic here...

defineAst(args[0], "Expr", [
    "Assign   : Token name, Expr value",
    "Binary   : Expr left, Token operator, Expr right",
    "Call     : Expr callee, Token paren, Expr[] args",
    "Get      : Expr object, Token name",
    "Grouping : Expr expression",
    "Literal  : unknown value",
    "Logical  : Expr left, Token operator, Expr right",
    "Set      : Expr object, Token name, Expr value",
    "Super    : Token keyword, Token method",
    "This     : Token keyword",
    "Unary    : Token operator, Expr right",
    "Variable : Token name"
], [
    `import { Token } from "${srcPath}/Lexer/Token";`
]);

defineAst(args[0], "Stmt", [
    "Block      : Stmt[] statements",
    "Class      : Token name, Variable | undefined superclass, Fun[] methods",
    "Expression : Expr expression",
    "Fun        : Token name, Token[] params, Stmt[] body",
    "If         : Expr condition, Stmt thenBranch, Stmt elseBranch?",
    "Print      : Expr expression",
    "Return     : Token keyword, Expr value?",
    "Var        : Token name, Expr initializer?",
    "While      : Expr condition, Stmt body"
], [
    `import { Expr, Variable } from "./Expr";`,
    `import { Token } from "${srcPath}/Lexer/Token";`
]);
