#!/usr/bin/env node

import { writeFile } from "fs/promises";
import { relative, resolve } from "path";

const args = process.argv.slice(2);
if (args.length != 1) {
    console.error("Usage: npm run ast [path-to-ast-dir]");
    process.exit(64);
}

type AstTypeDefField = {
    name: string;
    type: string;
};

type AstTypeDef = {
    name: string;
    fields: AstTypeDefField[];
}

async function defineAst(outputDir: string, baseName: string, types: string[]) {
    const filePath = resolve(`${outputDir}/${baseName}.ts`);
    const srcPath = relative(resolve(outputDir), resolve(__dirname + "/../src/")).replace("\\\\", "/"); // Some dark magic here...

    const typeDefs: AstTypeDef[] = types.map((type) => {
        const typeParts = type.split(":");
        return {
            name: typeParts[0].trim(),
            fields: typeParts[1].trim().split(",").map((field) => {
                const fieldParts = field.trim().split(" ");
                return {
                    name: fieldParts[1],
                    type: fieldParts[0]
                };
            })
        };
    });

    const fileLines: string[] = [
        `// WARNING: DO NOT EDIT THIS FILE MANUALLY!`,
        `// Please use the tool/generateAst.ts script using: \`npm run ast "src/ast"\``,
        ``,
        `import { Token } from "${srcPath}/Lexer/Token";`,
        ...defineVisitor(baseName, typeDefs),
        ...defineInterface(baseName),
        ...defineTypes(baseName, typeDefs)
    ];

    await writeFile(filePath, fileLines.join("\n") + "\n", { flag: "w+" });
}

function defineVisitor(baseName: string, typeDefs: AstTypeDef[]): string[] {
    return [
        ``,
        `export interface Visitor<T> {`,
        ...typeDefs.map((type) => {
            return `    visit${type.name}${baseName}(expr: ${type.name}): T;`;
        }),
        `}`
    ];
}

function defineInterface(baseName: string): string[] {
    return [
        ``,
        `export interface ${baseName} {`,
        `    accept<T>(visitor: Visitor<T>): T;`,
        `}`
    ];
}

function defineTypes(baseName: string, typeDefs: AstTypeDef[]): string[] {
    return typeDefs.reduce((lines, typeDef) => lines.concat([
        ``,
        `export class ${typeDef.name} implements ${baseName} {`,
        `    public constructor(`,
        ...typeDef.fields.map((field) => `        public readonly ${field.name}: ${field.type},`),
        `    ) { }`,
        ``,
        `    public accept<T>(visitor: Visitor<T>): T {`,
        `        return visitor.visit${typeDef.name}${baseName}(this);`,
        `    }`,
        `}`
    ]), [] as string[]);
}

// For more information about this file and syntax:
// http://craftinginterpreters.com/representing-code.html#metaprogramming-the-trees

defineAst(args[0], "Expr", [
    "Binary   : Expr left, Token operator, Expr right",
    "Grouping : Expr expression",
    "Literal  : unknown value",
    "Unary    : Token operator, Expr right"
]);
